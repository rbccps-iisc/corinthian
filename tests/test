#!/usr/bin/env python

import json
import math
import argparse
import random
import string
import argparse
import logging
import time
import warnings
import requests
import urllib3
import subprocess
from requests.adapters import HTTPAdapter

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logger = logging.getLogger(__name__)

base_url = "https://localhost:8888"

s = requests.Session();
s.mount('https://localhost:8888/', HTTPAdapter(pool_connections=1))

f = open("./vars/admin_pwd", "r")
admin_key = str(f.read())[:-1]

cmd = """ docker exec postgres psql -U postgres -c "insert into users values('admin1','fa8d4b8fe10794af430f04b7af55388be9f676361c49849daff827918b6bd2f3',NULL,'salt','f') ON CONFLICT DO NOTHING" """

try:
	p = subprocess.check_output(cmd, shell=True)
except Exception as e:
	pass

class colour:
	HEADER = '\033[95m'
	OKBLUE = '\033[94m'
	OKGREEN = '\033[92m'
	WARNING = '\033[93m'
	FAIL = '\033[91m'
	ENDC = '\033[0m'
	BOLD = '\033[1m'
	UNDERLINE = '\033[4m'

def check(response, code):
	
	if response.status_code == code:
		return True
	else:
		return False

def gen_rand(size, prefix=""):

	rand_str = prefix + ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(size))
	return rand_str

def register_owner(ID, apikey, owner):
	
	url = base_url + "/register-owner"
	headers = {"id": ID, "apikey": apikey, "owner": owner}
	r = s.post(url=url, headers=headers, verify=False)
	return r

def register(ID, apikey, entity_id):
	
	url = base_url + "/register"
	headers = {"id": ID, "apikey": apikey, "entity": entity_id}
	r = s.post(url=url, headers=headers, data="{\"test\":\"schema\"}", verify=False)
	return r

def deregister(ID, apikey, entity_id):

	url = base_url + "/deregister"
	headers = {"id": ID, "apikey": apikey, "entity": entity_id}
	r = s.get(url=url, headers=headers, verify=False)
	return r

def block_unblock(ID, apikey, entity_id, req_type):
	
	url = base_url 
	
	if req_type == "block":
		url = url + "/block"
	elif req_type == "unblock":
		url = url + "/unblock"

	headers = {"id": ID, "apikey": apikey, "entity": entity_id}
	r = s.get(url=url, headers=headers, verify=False)
	return r

def permissions(ID, apikey, entity_id=""):

	url = base_url + "/permissions"

	headers = {}

	if entity_id:
		headers['entity'] = entity_id

	headers ['id'] 		= ID
	headers	['apikey'] 	= apikey

	r = s.get(url=url, headers=headers, verify=False)
	return r

def publish(ID, apikey, to, topic, message_type, data):

	url = base_url + "/publish"
	headers = {"id": ID, "apikey": apikey, "to": to, "topic": topic, "message-type": message_type}
	r = s.post(url=url,headers=headers,data=data,verify=False)
	return r

def follow(ID, apikey, to_id, permission, from_id=""):

	url = base_url + "/follow"
	headers = {}

	if from_id:
		headers['from'] = from_id

	headers['id'] = ID
	headers['apikey'] = apikey
	headers['to'] = to_id
	headers['topic'] = "test"
	headers['validity'] = "24"
	headers['permission'] = permission
	
	r = s.get(url=url,headers=headers,verify=False)
	return r

def reject_follow(ID, apikey, follow_id):
	
	url =base_url + "/reject-follow"
	headers = {"id": ID, "apikey": apikey, "follow-id": follow_id}
	r = s.get(url=url, headers=headers, verify=False)
	return r
	

def unfollow(ID, apikey, to, topic, permission, message_type, from_id=""):

	url = base_url + "/unfollow"
	headers = {}

	if from_id:
		headers['from'] = from_id

	headers['id'] = ID
	headers['apikey'] = apikey
	headers['to'] = to
	headers['topic'] = "test"
	headers['permission'] = permission
	headers['message-type'] = message_type 
	
	r = s.get(url=url,headers=headers,verify=False)
	return r

def share(ID, apikey, follow_id):

	url =base_url + "/share"
	headers = {"id": ID, "apikey": apikey, "follow-id": follow_id}
	r = s.get(url=url, headers=headers, verify=False)
	return r

def bind_unbind(ID, apikey, to, topic, req_type, message_type, from_id=""):

	url = base_url
	headers = {}

	if req_type == "bind":
		url = url + "/bind"
	elif req_type == "unbind":
		url = url + "/unbind"

	if from_id:
		headers['from'] = from_id

	headers['message-type'] = message_type

	headers['id'] = ID
	headers['apikey'] = apikey
	headers['to'] = to
	headers['topic'] = topic

	r = s.get(url=url, headers=headers, verify=False)
	return r


def subscribe(ID, apikey, message_type="", num_messages=""):

	url = base_url + "/subscribe"
	headers = {}

	if message_type:
		headers['message-type'] = message_type

	if num_messages:
		headers['num-messages'] = num_messages

	headers['id'] = ID
	headers['apikey'] = apikey

	r = s.get(url=url, headers=headers, verify=False)
	return r

def follow_requests(ID, apikey, request_type):

	url = base_url

	if request_type == "requests":
		url = url + "/follow-requests"
	elif request_type == "status":
		url = url + "/follow-status"

	headers = {"id": ID, "apikey": apikey}

	r = s.get(url=url, headers=headers, verify=False)
	return r

def dev_publish(device_keys):

	for device, apikey in device_keys.items():
		logger.info("PUBLISHING MESSAGE FROM " + device)
		pub_req = publish(device, apikey, device, "test", "protected", "test message from " + device)
		pub_status = check(pub_req, 202)
		assert (pub_status)


def bind_unbind_dev(device_keys, app_keys, expected=0, as_admin="", req_type=""):

	if as_admin == False:

		approved = 0

		for app, apikey in app_keys.items():
			logger.info("APP " + app + " CHECKING APPROVAL STATUS OF FOLLOW REQUESTS BEFORE BINDING")
			follow_status = follow_requests(app, apikey, "status")
			response = follow_status.json() 
			flag = check(follow_status, 200)

			for entry in response:
				if entry['status'] == "approved":
					approved = approved + 1

			assert (approved == expected)
			logger.info("APP " + app + " HAS RECEIVED " + str(approved) + " APPROVALS")
			approved = 0

		for app, apikey in app_keys.items():
			for device in device_keys:
				logger.info("APP " + app + " (UN)BINDING FROM DEVICE " + device)
				bind_req = bind_unbind(app, apikey, device, "test", req_type, "protected")
				bind_status = check(bind_req, 200)
				assert (bind_status)

	elif as_admin == True:

		approved = 0

		for app in app_keys:

			logger.info("APP " + app + " CHECKING APPROVAL STATUS OF FOLLOW REQUESTS BEFORE BINDING")
			follow_status = follow_requests("admin1", "admin1", "status")
			response = follow_status.json()

			flag = check(follow_status, 200)

			for entry in response:
				if entry['status'] == "approved":
					approved = approved + 1

			assert (approved == expected)
			logger.info("APP ADMIN HAS RECEIVED " + str(approved) + " APPROVALS")
			approved = 0

		for app in app_keys:
			for device in device_keys:
				logger.info("APP " + app + " BINDING TO DEVICE " + device)
				bind_req = bind_unbind("admin1", "admin1", device, "test", req_type, "protected", from_id=app)
				bind_status = check(bind_req, 200)
				assert (bind_status)


def bind_unbind_without_follow(device_keys, app_keys, as_admin="", req_type=""):

	if as_admin == False:
			for app, apikey in app_keys.items():
					for device in device_keys:
						logger.info("APP " + app + " (UN)BINDING FROM DEVICE " + device)
						bind_req = bind_unbind(app, apikey, device, "test", req_type, "protected")
						bind_status = check(bind_req, 403)
						assert (bind_status)

	elif as_admin == True:
		for app in app_keys:
			for device in device_keys:
				logger.info("APP " + app + " BINDING TO DEVICE " + device)
				bind_req = bind_unbind("admin1", "admin1", device, "test", req_type, "protected", from_id=app)
				bind_status = check(bind_req, 403)
				assert (bind_status)

def app_subscribe(devices, app_keys, expected):

	count = math.ceil(devices / 10.0)

	actual = 0

	for app, apikey in app_keys.items():

		logger.info("APP " + app + " SUBSCRIBING TO ITS QUEUE")

		for i in range(0, int(count)):
			sub_req = subscribe(app, apikey, num_messages="10")
			response = sub_req.json() 
			actual = actual + len(response)
			sub_status = check(sub_req, 200)
			assert(sub_status)
		
		assert (actual == expected)
		actual = 0
		logger.info("APP " + app + " has successfully received " + str(expected) + " messages")


def follow_dev(device_keys, app_keys, as_admin="", permission=""):

	if as_admin == True:
		for app in app_keys:
			for device in device_keys:
				logger.info("FOLLOW REQUEST FROM APP " + app + " TO DEVICE " + device)
				r = follow("admin1", "admin1", device, permission, from_id=app)
				follow_status = check(r, 202)
				assert (follow_status)

	elif as_admin == False:
		for app, apikey in app_keys.items():
			for device in device_keys:
				logger.info("FOLLOW REQUEST FROM APP " + app + " TO DEVICE " + device)
				r = follow(app, apikey, device, permission)
				follow_status = check(r, 202)
				assert (follow_status)


def unfollow_dev(device_keys, app_keys, as_admin="", permission=""):

	if as_admin == True:
		for app in app_keys:
			for device in device_keys:
				logger.info("UNFOLLOW REQUEST FROM APP " + app + " TO DEVICE " + device)
				r = unfollow("admin1", "admin1", device, "test", permission, "protected", from_id=app)
				follow_status = check(r, 200)
				assert (follow_status)

	elif as_admin == False:
		for app, apikey in app_keys.items():
			for device in device_keys:
				logger.info("UNFOLLOW REQUEST FROM APP " + app + " TO DEVICE " + device)
				r = unfollow(app, apikey, device, "test", permission, "protected")
				follow_status = check(r, 200)
				assert (follow_status)

def share_dev(expected):

	r = follow_requests("admin", admin_key, "requests")
	response = r.json() 
	count = 0

	assert(check(r,200))
	
	for follow_req in response:
		count = count + 1
		logger.info("SHARE FROM DEVICE " + str(follow_req['to']).split(".")[0] + " TO APP " + str(follow_req['from']))
		share_req = share("admin", admin_key, str(follow_req['follow-id']))
		share_status = check(share_req, 200)
		assert (share_status)

	assert(count == expected)

def app_publish(device_keys, app_keys, expected_code):

	for app, apikey in app_keys.items():
		for device in device_keys:
			logger.info("APP "+ app +" PUBLISHING TO DEVICE "+ device +".command EXCHANGE")
			publish_req = publish(app,apikey, device, "test", "command", "data")
			assert(check(publish_req, expected_code))


def dev_subscribe(apps, device_keys, expected):

	count = math.ceil(apps / 10.0)

	actual = 0

	for device, apikey in device_keys.items():

		logger.info("DEVICE " + device + " SUBSCRIBING TO ITS COMMAND QUEUE")

		for i in range(0, int(count)):
			sub_req = subscribe(device, apikey, message_type="command", num_messages="10")
			response = sub_req.json() 
			actual = actual + len(response)
			sub_status = check(sub_req, 200)
			assert(sub_status)
		
		assert (actual == expected)
		actual = 0
		logger.info("DEVICE " + device + " HAS RECEIVED " + str(expected) + " COMMAND MESSAGES")

def registrations(devices, apps):
	
	device_keys = {}
	app_keys = {}

	# Device regsitration
	logger.info(colour.HEADER + "---------------> REGISTERING DEVICES " + colour.ENDC)

	for i in range(0, devices):
		logger.info("REGISTERING DEVICE " + str(i))
		dev_name = "dev" + ''.join(
		random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))
		r = register('admin', admin_key, dev_name)
		response = r.json()
		logger.info(json.dumps(response))
		reg_status = check(r, 200)

		assert (reg_status)

		device_keys[response['id']] = response['apikey']

	# App registration
	logger.info(colour.HEADER + "---------------> REGISTERING APPS" + colour.ENDC)

	for i in range(0, apps):
		logger.info("REGISTERING APP " + str(i))
		app_name = "app" + ''.join(
			random.choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))
		r = register('admin1', 'admin1', app_name)
		response = r.json()
		logger.info(json.dumps(response))
		reg_status = check(r, 200)

		assert (reg_status)

		app_keys[response['id']] = response['apikey']

	return device_keys, app_keys

def deregistrations(device_keys, app_keys):

	#Deregister all apps and devices
	logger.info(colour.HEADER+"---------------> DEREGISTERING DEVICES AND APPS"+colour.ENDC)

	for device in device_keys:
		logger.info("DEREGISTERING DEVICE "+ device +colour.ENDC)
		dereg = deregister("admin",admin_key,device)
		assert(check(dereg,200))
 
	for app in app_keys:
		logger.info("DEREGISTERING APP "+ app +colour.ENDC)
		dereg = deregister("admin1","admin1",app)
		assert(check(dereg,200))

def security_tests():

	print("\n\n")
	logger.info(colour.OKGREEN + colour.BOLD + "========================= SECURITY TESTS =========================\n\n"+colour.ENDC)
	
	dummy_key = gen_rand(32) 
	dummy_id  = gen_rand(16) 

	devices = random.randint(1,5)
	apps 	= random.randint(1,5)

	device_keys, app_keys = registrations(devices,apps)	

	#Trying to register an owner from outside the localhost
	
	#logger.info(colour.HEADER + "---------------> OWNER REGISTRATION FROM OUTSIDE LOCALHOST " + colour.ENDC)

	#r = register_owner("admin", admin_key, "owner"+dummy_id)
	#assert(check(r,403))
	#logger.info("Received 403: OK")


	#=========================================Invalid API key===============================================
	print("\n\n")
	logger.info(colour.OKGREEN+"------------------------- INVALID APIKEY -------------------------\n\n"+colour.ENDC)

	#Owner registration ( should not go through with the right apikey anyway ) 
	
	#logger.info(colour.HEADER + "---------------> OWNER REGISTRATION USING INVALID APIKEY " + colour.ENDC)
	#r = register_owner("admin", dummy_key, "owner"+dummy_id)
	#assert(check(r,403))
	#logger.info("Received 403: OK")

	#Registration
	logger.info(colour.HEADER + "---------------> REGISTRATION USING INVALID APIKEY" + colour.ENDC)
	
	r = register("admin", dummy_key, "dev"+dummy_id)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Publish
	logger.info(colour.HEADER + "---------------> PUBLISH USING INVALID APIKEY" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())
	r = publish(dev_name, dummy_key, dev_name, "test", "protected", "hello")
	assert(check(r,403))
	logger.info("Received 403: OK")

	logger.info(colour.HEADER + "---------------> PUBLISH USING VALID APIKEY TO ESTABLISH CONNECTION" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())
	r = publish(dev_name, str(device_keys[dev_name]), dev_name, "test", "protected", "hello")
	assert(check(r,202))
	logger.info("Received 202: OK")

	logger.info(colour.HEADER + "---------------> PUBLISH USING INVALID APIKEY ONCE CONNECTION HAS BEEN ESTABLISHED" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())
	r = publish(dev_name, dummy_key, dev_name, "test", "protected", "hello")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Subscribe
	logger.info(colour.HEADER + "---------------> SUBSCRIBE USING INVALID APIKEY" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = subscribe(dev_name, dummy_key)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow
	logger.info(colour.HEADER + "---------------> FOLLOW USING INVALID APIKEY" + colour.ENDC)

	app_name = random.choice(app_keys.keys())
	r = follow(app_name, dummy_key, random.choice(device_keys.keys()), "read")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Follow using invalid admin key
	logger.info(colour.HEADER + "---------------> FOLLOW USING INVALID ADMIN APIKEY" + colour.ENDC)

	app_name = random.choice(app_keys.keys())
	r = follow("admin1", dummy_key, random.choice(device_keys.keys()), "read")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Share
	logger.info(colour.HEADER + "---------------> SHARE USING INVALID APIKEY" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = share(dev_name, dummy_key, str(random.randint(0,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Share using invalid admin key
	logger.info(colour.HEADER + "---------------> SHARE USING INVALID ADMIN APIKEY" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = share("admin", dummy_key, str(random.randint(0,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unfollow
	logger.info(colour.HEADER + "---------------> UNFOLLOW USING INVALID APIKEY" + colour.ENDC)
	
	app_name = random.choice(app_keys.keys())
	r = unfollow(app_name, dummy_key, str(random.choice(device_keys.keys())), "test", "read", "protected")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unfollow using invalid admin apikey
	logger.info(colour.HEADER + "---------------> UNFOLLOW USING INVALID ADMIN APIKEY" + colour.ENDC)
	
	app_name = random.choice(app_keys.keys())
	r = unfollow("admin1", dummy_key, str(random.choice(device_keys.keys())), "test", "read", "protected", from_id=app_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow-requests
	logger.info(colour.HEADER + "---------------> FOLLOW-REQUESTS USING INVALID APIKEY" + colour.ENDC)

	r = follow_requests("admin", dummy_key, "requests")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Follow-requests using invalid device apikey
	logger.info(colour.HEADER + "---------------> FOLLOW-REQUESTS USING INVALID DEVICE APIKEY" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = follow_requests(dev_name, dummy_key, "requests")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow-status
	logger.info(colour.HEADER + "---------------> FOLLOW-STATUS USING INVALID APIKEY" + colour.ENDC)

	r = follow_requests("admin", dummy_key, "status")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow-status using invalid device apikey
	logger.info(colour.HEADER + "---------------> FOLLOW-STATUS USING INVALID DEVICE APIKEY" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = follow_requests(dev_name, dummy_key, "status")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Reject follow using invalid admin key
	logger.info(colour.HEADER + "---------------> REJECT-FOLLOW USING INVALID ADMIN APIKEY" + colour.ENDC)

	r = reject_follow("admin", dummy_key, str(random.randint(1,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")
		
	#Reject follow using invalid device key
	logger.info(colour.HEADER + "---------------> REJECT-FOLLOW USING INVALID DEVICE APIKEY" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = reject_follow(dev_name, dummy_key, str(random.randint(1,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Bind using invalid device apikey
	logger.info(colour.HEADER + "---------------> BIND USING INVALID DEVICE APIKEY" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(app_keys.keys())	
	
	r = bind_unbind(app_name, dummy_key, dev_name, "test", "bind", "protected")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Bind using invalid admin apikey
	logger.info(colour.HEADER + "---------------> BIND USING INVALID ADMIN APIKEY" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(app_keys.keys())	
	
	r = bind_unbind("admin1", dummy_key, dev_name, "test", "bind", "protected", from_id = app_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unbind using invalid device apikey
	logger.info(colour.HEADER + "---------------> UNBIND USING INVALID DEVICE APIKEY" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(device_keys.keys())	
	
	r = bind_unbind(app_name, dummy_key, dev_name, "test", "unbind", "protected")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Bind using invalid admin apikey
	logger.info(colour.HEADER + "---------------> UNBIND USING INVALID ADMIN APIKEY" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(device_keys.keys())	
	
	r = bind_unbind("admin1", dummy_key, dev_name, "test", "unbind", "protected", from_id = app_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Block using invalid admin apikey	
	logger.info(colour.HEADER + "---------------> BLOCK USING INVALID ADMIN APIKEY" + colour.ENDC)

	r = block_unblock("admin", dummy_key, str(random.choice(app_keys.keys())), "block")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unblock using invalid admin apikey	
	logger.info(colour.HEADER + "---------------> UNBLOCK USING INVALID ADMIN APIKEY" + colour.ENDC)

	r = block_unblock("admin", dummy_key, str(random.choice(app_keys.keys())), "unblock")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Permissions using invalid admin apikey
	logger.info(colour.HEADER + "---------------> PERMISSIONS USING INVALID ADMIN APIKEY" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())	

	r = permissions("admin", dummy_key, entity_id = dev_name)
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Permissions using invalid device apikey
	logger.info(colour.HEADER + "---------------> PERMISSIONS USING INVALID DEVICE APIKEY" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())	

	r = permissions(dev_name, dummy_key)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Deregister using invalid apikey
	
	logger.info(colour.HEADER + "---------------> DEREGISTRATION USING INVALID ADMIN APIKEY" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())	
	r = deregister("admin", dummy_key, dev_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#=========================================Invalid ID===============================================
	
	dummy_key = gen_rand(32) 
	dummy_id  = gen_rand(16, prefix="admin/") 
	dummy_admin_id = gen_rand(16) 

	print("\n\n")
	logger.info(colour.OKGREEN+"------------------------- INVALID ID -------------------------\n\n"+colour.ENDC)

	#Owner registration ( should not go through with the right apikey anyway ) 
	
	#logger.info(colour.HEADER + "---------------> OWNER REGISTRATION USING INVALID APIKEY " + colour.ENDC)
	#r = register_owner("admin", dummy_key, "owner"+dummy_id)
	#assert(check(r,403))
	#logger.info("Received 403: OK")

	#Registration
	logger.info(colour.HEADER + "---------------> REGISTRATION USING INVALID ID" + colour.ENDC)
	
	r = register(dummy_id, admin_key, "dev"+dummy_id)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Publish
	logger.info(colour.HEADER + "---------------> PUBLISH USING INVALID ID" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())
	r = publish(dummy_id, str(device_keys[dev_name]), dummy_id, "test", "protected", "hello")
	assert(check(r,403))
	logger.info("Received 403: OK")

	logger.info(colour.HEADER + "---------------> PUBLISH USING VALID APIKEY AND ID TO ESTABLISH CONNECTION" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())
	r = publish(dev_name, str(device_keys[dev_name]), dev_name, "test", "protected", "hello")
	assert(check(r,202))
	logger.info("Received 202: OK")

	logger.info(colour.HEADER + "---------------> PUBLISH USING INVALID ID ONCE CONNECTION HAS BEEN ESTABLISHED" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())
	r = publish(dummy_id, str(device_keys[dev_name]), dummy_id , "test", "protected", "hello")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Subscribe
	logger.info(colour.HEADER + "---------------> SUBSCRIBE USING INVALID ID" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = subscribe(dummy_id, str(device_keys[dev_name]))
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow
	logger.info(colour.HEADER + "---------------> FOLLOW USING INVALID ID" + colour.ENDC)

	app_name = random.choice(app_keys.keys())
	r = follow(dummy_id, str(app_keys[app_name]), random.choice(device_keys.keys()), "read")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Follow using invalid admin id
	logger.info(colour.HEADER + "---------------> FOLLOW USING INVALID ADMIN ID" + colour.ENDC)

	app_name = random.choice(app_keys.keys())
	r = follow(dummy_id, "admin1", random.choice(device_keys.keys()), "read")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Share
	logger.info(colour.HEADER + "---------------> SHARE USING INVALID ID" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = share(dummy_id, str(device_keys[dev_name]), str(random.randint(0,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Share using invalid admin id
	logger.info(colour.HEADER + "---------------> SHARE USING INVALID ADMIN ID" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = share(dummy_id, admin_key, str(random.randint(0,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unfollow
	logger.info(colour.HEADER + "---------------> UNFOLLOW USING INVALID ID" + colour.ENDC)
	
	app_name = random.choice(app_keys.keys())
	r = unfollow(dummy_id, str(app_keys[app_name]), str(random.choice(device_keys.keys())), "test", "read", "protected")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unfollow using invalid admin id
	logger.info(colour.HEADER + "---------------> UNFOLLOW USING INVALID ADMIN ID" + colour.ENDC)
	
	app_name = random.choice(app_keys.keys())
	r = unfollow(dummy_id, "admin1", str(random.choice(device_keys.keys())), "test", "read", "protected", from_id=app_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow-requests
	logger.info(colour.HEADER + "---------------> FOLLOW-REQUESTS USING INVALID ID" + colour.ENDC)

	r = follow_requests(dummy_id, admin_key, "requests")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Follow-requests using invalid device id
	logger.info(colour.HEADER + "---------------> FOLLOW-REQUESTS USING INVALID DEVICE ID" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = follow_requests(dummy_id, str(device_keys[dev_name]), "requests")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow-status
	logger.info(colour.HEADER + "---------------> FOLLOW-STATUS USING INVALID ID" + colour.ENDC)

	r = follow_requests(dummy_id, admin_key , "status")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Follow-status using invalid device id
	logger.info(colour.HEADER + "---------------> FOLLOW-STATUS USING INVALID DEVICE ID" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = follow_requests(dummy_id, str(device_keys[dev_name]), "status")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Reject follow using invalid admin id
	logger.info(colour.HEADER + "---------------> REJECT-FOLLOW USING INVALID ADMIN ID" + colour.ENDC)

	r = reject_follow(dummy_id, admin_key, str(random.randint(1,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")
		
	#Reject follow using invalid device id
	logger.info(colour.HEADER + "---------------> REJECT-FOLLOW USING INVALID DEVICE ID" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())
	r = reject_follow(dummy_id, str(device_keys[dev_name]), str(random.randint(1,5)))
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Bind using invalid device id
	logger.info(colour.HEADER + "---------------> BIND USING INVALID DEVICE ID" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(app_keys.keys())	
	
	r = bind_unbind(dummy_id, str(app_keys[app_name]), dev_name, "test", "bind", "protected")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Bind using invalid admin id
	logger.info(colour.HEADER + "---------------> BIND USING INVALID ADMIN ID" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(app_keys.keys())	
	
	r = bind_unbind(dummy_id, "admin1", dev_name, "test", "bind", "protected", from_id = app_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unbind using invalid device id
	logger.info(colour.HEADER + "---------------> UNBIND USING INVALID DEVICE ID" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(device_keys.keys())	
	
	r = bind_unbind(dummy_id, str(app_keys[app_name]), dev_name, "test", "unbind", "protected")
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Bind using invalid admin idy
	logger.info(colour.HEADER + "---------------> UNBIND USING INVALID ADMIN ID" + colour.ENDC)

	app_name = random.choice(app_keys.keys())	
	dev_name = random.choice(device_keys.keys())	
	
	r = bind_unbind(dummy_id, "admin1", dev_name, "test", "unbind", "protected", from_id = app_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Block using invalid admin id	
	logger.info(colour.HEADER + "---------------> BLOCK USING INVALID ADMIN ID" + colour.ENDC)

	r = block_unblock(dummy_admin_id, admin_key, str(random.choice(device_keys.keys())), "block")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Unblock using invalid admin id	
	logger.info(colour.HEADER + "---------------> UNBLOCK USING INVALID ADMIN ID" + colour.ENDC)

	r = block_unblock(dummy_admin_id, admin_key, str(random.choice(device_keys.keys())), "unblock")
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Permissions using invalid admin id
	logger.info(colour.HEADER + "---------------> PERMISSIONS USING INVALID ADMIN ID" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())	

	r = permissions(dummy_admin_id, admin_key, entity_id = dev_name)
	assert(check(r,403))
	logger.info("Received 403: OK")
	
	#Permissions using invalid device id
	logger.info(colour.HEADER + "---------------> PERMISSIONS USING INVALID DEVICE ID" + colour.ENDC)
	
	dev_name = random.choice(device_keys.keys())	

	r = permissions(dummy_id, str(device_keys[dev_name]))
	assert(check(r,403))
	logger.info("Received 403: OK")

	#Deregister using invalid id
	
	logger.info(colour.HEADER + "---------------> DEREGISTRATION USING INVALID ADMIN ID" + colour.ENDC)

	dev_name = random.choice(device_keys.keys())	
	r = deregister(dummy_id, admin_key, dev_name)
	assert(check(r,403))
	logger.info("Received 403: OK")

	print("\n\n")
	logger.info(colour.OKGREEN+"------------------------- PUBLISH -------------------------\n\n"+colour.ENDC)

	#Publish to non-existent exchange
	logger.info(colour.HEADER + "---------------> PUBLISH TO NON-EXISTENT EXCHANGE" + colour.ENDC)

	dev_name = str(random.choice(device_keys.keys()))
	dev_key  = str(device_keys[dev_name])
	
	dummy_exchange = gen_rand(8, prefix = gen_rand(8)+"/") 
	print(dummy_exchange)
	r = publish(dev_name, dev_key, dummy_exchange, "test", "command", "hello") 
	assert(check(r,202))
	logger.info("Received 202: OK")

	#Publish without authroisation
	logger.info(colour.HEADER + "---------------> PUBLISH WITHOUT AUTHORISATION" + colour.ENDC)

	app_name = str(random.choice(app_keys.keys()))
	dev_name = str(random.choice(device_keys.keys()))

	r = publish(app_name, str(app_keys[app_name]), dev_name, "test", "command", "hello") 
	assert(check(r,202))
	logger.info("Received 202: OK")

	#Publish to amq.topic
	logger.info(colour.HEADER + "---------------> PUBLISH TO amq.topic" + colour.ENDC)

	dev_name = str(random.choice(device_keys.keys()))

	r = publish(dev_name, str(device_keys[dev_name]), "amq.topic", "test", "command", "hello") 
	assert(check(r,202))
	logger.info("Received 202: OK")

	#Publish to amq.direct
	logger.info(colour.HEADER + "---------------> PUBLISH TO amq.direct" + colour.ENDC)

	dev_name = str(random.choice(device_keys.keys()))

	r = publish(dev_name, str(device_keys[dev_name]), "amq.direct", "test", "command", "hello") 
	assert(check(r,202))
	logger.info("Received 202: OK")

	#Publish to amq.headers
	logger.info(colour.HEADER + "---------------> PUBLISH TO amq.headers" + colour.ENDC)
	
	dev_name = str(random.choice(device_keys.keys()))

	r = publish(dev_name, str(device_keys[dev_name]), "amq.headers", "test", "command", "hello") 
	assert(check(r,202))
	logger.info("Received 202: OK")

	#Publish to amq.fanout
	logger.info(colour.HEADER + "---------------> PUBLISH TO amq.fanout" + colour.ENDC)

	dev_name = str(random.choice(device_keys.keys()))

	r = publish(dev_name, str(device_keys[dev_name]), "amq.fanout", "test", "command", "hello") 
	assert(check(r,202))
	logger.info("Received 202: OK")

def functional_tests(devices, apps):
	
	logger.info(colour.OKGREEN + colour.BOLD + "========================= FUNCTIONAL TESTS =========================\n\n"+colour.ENDC)
	device_keys, app_keys = registrations(devices,apps)

	# Follow requests from apps to devices using apps' respective apikeys
	logger.info(colour.HEADER + "---------------> FOLLOW REQUESTS WITH READ PERMISSION " + colour.ENDC)
	follow_dev(device_keys, app_keys, as_admin=False, permission="read")

	# Devices read all follow requests and share with apps
	logger.info(colour.HEADER + "---------------> DEVICES READ FOLLOW REQUESTS AND ISSUE SHARE TO APPS" + colour.ENDC)

	share_dev(apps*devices)

	# Apps bind to devices' queues
	logger.info(colour.HEADER + "---------------> APPS BIND TO DEVICES" + colour.ENDC)
	bind_unbind_dev(device_keys, app_keys, expected=devices, as_admin=False, req_type="bind")

	# Devices publish data
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA" + colour.ENDC)
	dev_publish(device_keys)

	# Apps subscribe to messages
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA" + colour.ENDC)
	app_subscribe(devices, app_keys, devices)

	# Apps unbind from devices
	logger.info(colour.HEADER + "---------------> APPS UNBIND FROM DEVICES" + colour.ENDC)
	bind_unbind_dev(device_keys, app_keys, expected=devices, as_admin=False, req_type="unbind")

	# Devices again publish messages
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA" + colour.ENDC)
	dev_publish(device_keys)

	# Apps try to subscribe
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA" + colour.ENDC)
	app_subscribe(devices, app_keys, 0)

	# Apps bind to devices again but this time using admin apikey
	logger.info(colour.HEADER + "---------------> APPS BIND TO DEVICES USING ADMIN APIKEY" + colour.ENDC)

	bind_unbind_dev(device_keys, app_keys, expected=devices*apps, as_admin=True, req_type="bind")

	# Devices publish again
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA" + colour.ENDC)
	dev_publish(device_keys)

	# Apps subscribe to messages
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA" + colour.ENDC)
	app_subscribe(devices, app_keys, devices)

	# Unbind from devices as admin
	logger.info(colour.HEADER + "---------------> APPS UNBIND FROM DEVICES USING ADMIN APIKEY" + colour.ENDC)

	bind_unbind_dev(device_keys, app_keys, expected=(devices*apps), as_admin=True, req_type="unbind")

	# Devices now publish data
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA" + colour.ENDC)
	dev_publish(device_keys)

	# Apps try to subscribe but get 0 messages
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA" + colour.ENDC)
	app_subscribe(devices, app_keys, 0)

	# Apps unfollow all devices
	logger.info(colour.HEADER + "---------------> APPS UNFOLLOW ALL DEVICES USING THEIR RESPECTIVE APIKEYS" + colour.ENDC)
	unfollow_dev(device_keys, app_keys, as_admin=False, permission="read")

	# Apps try to bind to unfollowed devices
	logger.info(colour.HEADER + "---------------> APPS TRY TO BIND TO UNFOLLOWED DEVICES" + colour.ENDC)
	bind_unbind_without_follow(device_keys, app_keys, as_admin=False, req_type="bind")

	#Follow requests as admin	
	logger.info(colour.HEADER + "---------------> FOLLOW REQUESTS WITH READ PERMISSION AS ADMIN" + colour.ENDC)
	follow_dev(device_keys, app_keys, as_admin=True, permission="read")

	#Devices share with apps
	logger.info(colour.HEADER + "---------------> DEVICES READ FOLLOW REQUESTS AND ISSUE SHARE TO APPS" + colour.ENDC)

	share_dev(apps*devices)

	# Apps bind to devices' queues
	logger.info(colour.HEADER + "---------------> APPS BIND TO DEVICES" + colour.ENDC)
	bind_unbind_dev(device_keys, app_keys, expected=devices, as_admin=False, req_type="bind")

	# Devices publish data
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA" + colour.ENDC)
	dev_publish(device_keys)

	# Apps subscribe to messages
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA" + colour.ENDC)
	app_subscribe(devices, app_keys, devices)

	# Apps unfollow all devices
	logger.info(colour.HEADER + "---------------> APPS UNFOLLOW ALL DEVICES USING THEIR ADMIN APIKEYS" + colour.ENDC)
	unfollow_dev(device_keys, app_keys, as_admin=True, permission="read")

	# Apps try to bind to unfollowed devices
	logger.info(colour.HEADER + "---------------> APPS TRY TO BIND TO UNFOLLOWED DEVICES" + colour.ENDC)
	bind_unbind_without_follow(device_keys, app_keys, as_admin=False, req_type="bind")

	#Follow requests for write	
	logger.info(colour.HEADER + "---------------> FOLLOW REQUESTS WITH WRITE PERMISSIONS" + colour.ENDC)
	follow_dev(device_keys, app_keys, as_admin=False, permission="write")

	#Devices share with apps with write access
	logger.info(colour.HEADER + "---------------> DEVICES READ FOLLOW REQUESTS AND ISSUE SHARE TO APPS" + colour.ENDC)
	share_dev(apps*devices)

	#Apps publish to command queue of devices
	logger.info(colour.HEADER+"---------------> APPS PUBLISH TO COMMAND EXCHANGE OF DEVICES"+colour.ENDC)
	app_publish(device_keys, app_keys, 202)

	#Devices subscribe to their command queue
	logger.info(colour.HEADER+"---------------> DEVICES SUBSCRIBE TO THEIR COMMAND QUEUES"+colour.ENDC)
	dev_subscribe(apps, device_keys, apps)

	#Follow requests for write	
	logger.info(colour.HEADER+"---------------> APPS WITH WRITE ACCESS UNFOLLOW DEVICES" + colour.ENDC)
	unfollow_dev(device_keys, app_keys, as_admin=False, permission="write")

	#Apps publish to command queue of devices
	logger.info(colour.HEADER+"---------------> APPS TRY TO PUBLISH TO COMMAND EXCHANGE OF UNFOLLOWED DEVICES"+colour.ENDC)
	app_publish(device_keys, app_keys, 202)

	#Apps request follow with read-write permissions
	logger.info(colour.HEADER+"---------------> APPS REQUEST FOLLOW WITH READ-WRITE PERMISSIONS"+colour.ENDC)
	follow_dev(device_keys, app_keys, as_admin=False, permission="read-write")

	#Devices approve issue share to apps
	logger.info(colour.HEADER+"---------------> DEVICES APPROVE READ-WRITE FOLLOW REQUESTS WITH SHARE"+colour.ENDC)
	share_dev(devices*apps*2)

	#Apps publish to command queue of devices
	logger.info(colour.HEADER+"---------------> APPS PUBLISH TO COMMAND EXCHANGE OF DEVICES"+colour.ENDC)
	app_publish(device_keys, app_keys, 202)

	#Devices subscribe to their command queue
	logger.info(colour.HEADER+"---------------> DEVICES SUBSCRIBE TO THEIR COMMAND QUEUES"+colour.ENDC)
	dev_subscribe(apps, device_keys, apps)
	
	# Apps bind to devices' queues
	logger.info(colour.HEADER + "---------------> APPS BIND TO DEVICES" + colour.ENDC)
	bind_unbind_dev(device_keys, app_keys, expected=(2*devices), as_admin=False, req_type="bind")

	# Devices publish again
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA" + colour.ENDC)
	dev_publish(device_keys)

	# Apps subscribe to messages
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA" + colour.ENDC)
	app_subscribe(devices, app_keys, devices)

	#Apps relinquish write permission
	logger.info(colour.HEADER+"---------------> APPS WITH WRITE ACCESS UNFOLLOW DEVICES" + colour.ENDC)
	unfollow_dev(device_keys, app_keys, as_admin=False, permission="write")

	#Apps publish to command queue of devices
	logger.info(colour.HEADER+"---------------> APPS TRY TO PUBLISH TO COMMAND EXCHANGE OF UNFOLLOWED DEVICES"+colour.ENDC)
	app_publish(device_keys, app_keys, 202)

	# Devices publish again
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA AFTER WRITE UNFOLLOW" + colour.ENDC)
	dev_publish(device_keys)

	# Apps subscribe to messages
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA AFTER WRITE UNFOLLOW" + colour.ENDC)
	app_subscribe(devices, app_keys, devices)

	# Apps unfollow with read permissions
	logger.info(colour.HEADER + "---------------> APPS UNFOLLOW DEVICES WITH READ ACCESS" + colour.ENDC)
	unfollow_dev(device_keys, app_keys, as_admin=True, permission="read")

	# Apps try to bind to unfollowed devices
	logger.info(colour.HEADER + "---------------> APPS TRY TO BIND TO UNFOLLOWED DEVICES" + colour.ENDC)
	bind_unbind_without_follow(device_keys, app_keys, as_admin=False, req_type="bind")

	#Apps obtain read-write follow
	logger.info(colour.HEADER+"---------------> APPS FOLLOW WITH READ-WRITE PERMISSIONS"+colour.ENDC)
	follow_dev(device_keys, app_keys, as_admin=False, permission="read-write")

	#Devices approve issue share to apps
	logger.info(colour.HEADER+"---------------> DEVICES APPROVE READ-WRITE FOLLOW REQUESTS WITH SHARE"+colour.ENDC)
	share_dev(devices*apps*2)

	# Apps bind to devices' queues
	logger.info(colour.HEADER + "---------------> APPS BIND TO DEVICES WITH ADMIN APIKEY" + colour.ENDC)
	bind_unbind_dev(device_keys, app_keys, expected=(2*devices*apps), as_admin=True, req_type="bind")

	# Devices publish again
	logger.info(colour.HEADER + "---------------> DEVICES PUBLISH DATA" + colour.ENDC)
	dev_publish(device_keys)

	# Apps subscribe to messages
	logger.info(colour.HEADER + "---------------> APPS TRY TO READ PUBLISHED DATA" + colour.ENDC)
	app_subscribe(devices, app_keys, devices)

	# Apps unfollow with read permissions
	logger.info(colour.HEADER + "---------------> APPS UNFOLLOW DEVICES WITH READ-WRITE ACCESS" + colour.ENDC)
	unfollow_dev(device_keys, app_keys, as_admin=True, permission="read-write")

	deregistrations(device_keys, app_keys)
	

def start_tests(devices, apps, args):
	
	if args.choice == "fxnl":
		
		test_time = time.time()
		functional_tests(devices, apps)
		test_time = time.time() - test_time
	
	elif args.choice == "sec":
		
		test_time = time.time()
		security_tests()
		test_time = time.time() - test_time

	elif args.choice == "concr":
		
		test_time = time.time()
		concurrency_tests(devices, apps)
		test_time = time.time() - test_time

	elif args.choice == "all":
		
		test_time = time.time()
		all_tests(devices, apps)
		test_time = time.time() - test_time
	

	print("\n\n"+colour.OKGREEN+colour.BOLD+"====================All tests have passed===================="+colour.ENDC)
	#print(colour.OKGREEN+"Registrations    : "+str(reg_time)+"s"+colour.ENDC)
	print(colour.OKGREEN+"Test cases       : "+str(test_time)+"s"+colour.ENDC)
	#print(colour.OKGREEN+"Deregistrations  : "+str(dereg_time)+"s"+colour.ENDC)

if __name__ == '__main__':

	parser = argparse.ArgumentParser(description='Test cases for Corinthian')
	subparser = parser.add_subparsers(dest="choice")

	func_parser = subparser.add_parser("fxnl", help="Performs functional tests")

	func_parser.add_argument('-d', '--devices', action="store", dest="devices", type=int, help="No. of devices to run the tests")
	func_parser.add_argument('-a', '--apps', action="store", dest="apps", type=int, help="No. of apps to run the tests")
	func_parser.add_argument('--random', action="store_true", help="Run tests with random devices and apps")

	sec_parser = subparser.add_parser("sec", help="Performs security tests")

	conc_parser = subparser.add_parser("concr", help="Performs concurrency tests")

	conc_parser.add_argument('-d', '--devices', action="store", dest="devices", type=int, help="No. of devices to run the tests")
	conc_parser.add_argument('-a', '--apps', action="store", dest="apps", type=int, help="No. of apps to run the tests")
	conc_parser.add_argument('--random', action="store_true", help="Run tests with random devices and apps")
	
	all_parser = subparser.add_parser("all", help="Performs all of the above tests")

	all_parser.add_argument('-d', '--devices', action="store", dest="devices", type=int, help="No. of devices to run the tests")
	all_parser.add_argument('-a', '--apps', action="store", dest="apps", type=int, help="No. of apps to run the tests")
	all_parser.add_argument('--random', action="store_true", help="Run tests with random devices and apps")
	
	args = parser.parse_args()

	devices = 0
	apps 	= 0					

	if args.choice <> "sec":

		if args.random:
			devices = random.randint(10,20)
			apps 	= random.randint(10,20)
		else:
			devices = args.devices
			apps = args.apps
		
	logging.basicConfig(format='%(asctime)s %(levelname)-6s %(message)s', level=logging.DEBUG,
						datefmt='%Y-%m-%d %H:%M:%S')
	logging.getLogger("requests").setLevel(logging.WARNING)
	logging.getLogger("urllib3").setLevel(logging.WARNING)

	start_tests(devices, apps, args)
